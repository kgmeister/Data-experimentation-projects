import os
import sys
import subprocess
import json
import re
from pathlib import Path
from datetime import datetime, timedelta

# --- Auto-install dependencies if missing ---
REQUIRED = ["flask", "requests", "pandas", "python-dateutil", "waitress"]
def ensure_deps():
    import importlib
    missing = []
    for pkg in REQUIRED:
        try:
            importlib.import_module(pkg.replace("-", "_"))
        except ImportError:
            missing.append(pkg)
    if missing:
        print(f"Installing missing packages: {', '.join(missing)}")
        subprocess.check_call([sys.executable, "-m", "pip", "install", *missing])

ensure_deps()

from flask import Flask, request, jsonify, render_template_string
import requests
import pandas as pd
from dateutil import parser as dateparser

# --- Configuration ---
BITDEER_API_KEY = os.getenv("BITDEER_API_KEY", "").strip()
BITDEER_CHAT_URL = "https://api-inference.bitdeer.ai/v1/chat/completions"

# Models
MODEL_GPT_OSS = "openai/gpt-oss-120b"
MODEL_QWEN3 = "Qwen/Qwen3-235B-A22B"
DEFAULT_MODEL = MODEL_GPT_OSS

# Data paths (Windows default)
DATA_DIR = Path(r"C:\Team_Cashew_Synthetic_Data")
FAQS_CSV = DATA_DIR / "faqs.csv"
INVENTORY_CSV = DATA_DIR / "product_inventory_master.csv"
SALES_CSV = DATA_DIR / "product_platform_sales.csv"
CAMPAIGNS_CSV = DATA_DIR / "sales_campaign_performance.csv"
CUSTOMERS_CSV = DATA_DIR / "customers_insights.csv"
ORDERS_CSV = DATA_DIR / "platform_performance_orders.csv"

# --- App setup ---
app = Flask(__name__)

# --- Utilities ---
def safe_read_csv(path: Path):
    if not path.exists():
        print(f"[WARN] CSV not found: {path}")
        return pd.DataFrame()
    for enc in ("utf-8", "utf-8-sig", "latin-1"):
        try:
            df = pd.read_csv(path, encoding=enc)
            print(f"[INFO] Loaded {path.name} ({enc}) with {len(df)} rows.")
            return df
        except Exception as e:
            last_err = e
    print(f"[ERROR] Failed to read {path}: {last_err}")
    return pd.DataFrame()

def norm_cols(df: pd.DataFrame) -> pd.DataFrame:
    if df is None or df.empty:
        return df
    df = df.copy()
    df.columns = [str(c).strip().lower() for c in df.columns]
    return df

def pick(df: pd.DataFrame, candidates):
    if df is None or df.empty:
        return None
    cols = set(df.columns)
    for cand in candidates:
        if cand in cols:
            return cand
    # fuzzy contains
    for c in df.columns:
        for cand in candidates:
            if cand in c:
                return c
    return None

def to_datetime_safe(val):
    if pd.isna(val) or val is None or str(val).strip() == "":
        return None
    try:
        return dateparser.parse(str(val), dayfirst=False)
    except Exception:
        return None

def parse_date_range_from_text(text: str):
    # Recognize "last 7/30/90 days", "last month", "this month/year", explicit months/years
    now = datetime.now()
    t = text.lower()
    # last N days
    m = re.search(r"last\s+(\d{1,3})\s*days?", t)
    if m:
        n = int(m.group(1))
        start = now - timedelta(days=n)
        return start.replace(hour=0, minute=0, second=0, microsecond=0), now
    # last month
    if "last month" in t:
        first_this = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        last_month_end = first_this - timedelta(seconds=1)
        first_last = last_month_end.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        return first_last, last_month_end
    # this month
    if "this month" in t:
        first_this = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        return first_this, now
    # this year
    if "this year" in t:
        first = now.replace(month=1, day=1, hour=0, minute=0, second=0, microsecond=0)
        return first, now
    # YYYY
    m = re.search(r"(20\d{2})", t)
    if m:
        year = int(m.group(1))
        start = datetime(year, 1, 1)
        end = datetime(year, 12, 31, 23, 59, 59)
        return start, end
    # Month name (basic)
    months = {m.lower(): i for i, m in enumerate(["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"], start=1)}
    for name, idx in months.items():
        if re.search(rf"\b{name}\w*\b", t):
            year = datetime.now().year
            start = datetime(year, idx, 1)
            next_m = idx + 1
            if next_m == 13:
                end = datetime(year, 12, 31, 23, 59, 59)
            else:
                end = datetime(year, next_m, 1) - timedelta(seconds=1)
            return start, end
    return None, None

def sanitize_float(x):
    try:
        return float(x)
    except Exception:
        return None

# --- Load all data ---
faqs_df = norm_cols(safe_read_csv(FAQS_CSV))
inv_df = norm_cols(safe_read_csv(INVENTORY_CSV))
sales_df = norm_cols(safe_read_csv(SALES_CSV))
camp_df = norm_cols(safe_read_csv(CAMPAIGNS_CSV))
cust_df = norm_cols(safe_read_csv(CUSTOMERS_CSV))
orders_df = norm_cols(safe_read_csv(ORDERS_CSV))

# --- Column mappings (flexible detection) ---
# FAQs
FAQ_Q_COL = pick(faqs_df, ["question", "faq_question", "q"])
FAQ_A_COL = pick(faqs_df, ["answer", "response", "a"])

# Inventory
INV_NAME_COL = pick(inv_df, ["product_name", "name", "product"])
INV_SKU_COL = pick(inv_df, ["sku", "product_id", "id", "item_id"])
INV_STOCK_COL = pick(inv_df, ["stock", "qty", "quantity", "on_hand", "inventory"])
INV_PRICE_COL = pick(inv_df, ["price", "unit_price", "cost"])
INV_VARIANT_COL = pick(inv_df, ["variant", "size", "grade", "pack", "option"])

# Sales
SALE_DATE_COL = pick(sales_df, ["date", "order_date", "day"])
SALE_SKU_COL = pick(sales_df, ["sku", "product_id", "id"])
SALE_NAME_COL = pick(sales_df, ["product_name", "name", "product"])
SALE_UNITS_COL = pick(sales_df, ["units", "qty", "quantity"])
SALE_REV_COL = pick(sales_df, ["revenue", "sales", "amount"])
SALE_PLATFORM_COL = pick(sales_df, ["platform", "channel"])

# Campaigns
CAMP_CODE_COL = pick(camp_df, ["promo_code", "code", "coupon"])
CAMP_NAME_COL = pick(camp_df, ["campaign_name", "name"])
CAMP_START_COL = pick(camp_df, ["start_date", "start", "from"])
CAMP_END_COL = pick(camp_df, ["end_date", "end", "until", "expires_at", "expiry"])
CAMP_CHANNEL_COL = pick(camp_df, ["channel", "platform"])
CAMP_SPEND_COL = pick(camp_df, ["spend", "cost"])
CAMP_REV_COL = pick(camp_df, ["revenue", "sales"])
CAMP_CLICKS_COL = pick(camp_df, ["clicks"])
CAMP_IMP_COL = pick(camp_df, ["impressions", "imps"])

# Customers
CUST_ID_COL = pick(cust_df, ["customer_id", "id"])
CUST_EMAIL_COL = pick(cust_df, ["email", "customer_email"])
CUST_PHONE_COL = pick(cust_df, ["phone", "mobile"])
CUST_NAME_COL = pick(cust_df, ["name", "full_name", "customer_name"])
CUST_TOTAL_ORDERS_COL = pick(cust_df, ["total_orders", "orders_count"])

# Orders
ORD_ID_COL = pick(orders_df, ["order_id", "id"])
ORD_NUM_COL = pick(orders_df, ["order_number", "order_no", "number"])
ORD_CUST_ID_COL = pick(orders_df, ["customer_id"])
ORD_EMAIL_COL = pick(orders_df, ["email", "customer_email"])
ORD_STATUS_COL = pick(orders_df, ["status", "order_status"])
ORD_FULFILL_COL = pick(orders_df, ["fulfillment_status", "fulfilment_status"])
ORD_PAY_COL = pick(orders_df, ["payment_status", "pay_status"])
ORD_CREATED_COL = pick(orders_df, ["created_at", "order_date", "date"])
ORD_FULFILLED_COL = pick(orders_df, ["fulfilled_at", "shipped_at"])
ORD_TOTAL_COL = pick(orders_df, ["total", "grand_total", "amount"])

# --- Retrieval helpers ---
def search_faqs(query: str, top_k: int = 3):
    if faqs_df.empty or not FAQ_Q_COL or not FAQ_A_COL:
        return []
    q = query.lower()
    words = set(re.findall(r"[a-z0-9]+", q))
    scored = []
    for _, row in faqs_df.iterrows():
        text = f"{row.get(FAQ_Q_COL,'')} {row.get(FAQ_A_COL,'')}".lower()
        score = sum(1 for w in words if w and w in text)
        if score > 0:
            scored.append((score, row))
    scored.sort(key=lambda x: x[0], reverse=True)
    results = []
    for s, r in scored[:top_k]:
        results.append({"question": str(r.get(FAQ_Q_COL, "")), "answer": str(r.get(FAQ_A_COL, "")), "_score": s})
    return results

def search_inventory(query: str, top_k: int = 5):
    if inv_df.empty or not INV_NAME_COL:
        return []
    q = query.lower()
    words = set(re.findall(r"[a-z0-9]+", q))
    hits = []
    for _, row in inv_df.iterrows():
        text = " ".join([
            str(row.get(INV_NAME_COL, "")),
            str(row.get(INV_VARIANT_COL, "")) if INV_VARIANT_COL else "",
            str(row.get(INV_SKU_COL, "")) if INV_SKU_COL else ""
        ]).lower()
        score = sum(1 for w in words if w and w in text)
        if score > 0:
            hits.append((score, row))
    hits.sort(key=lambda x: x[0], reverse=True)
    results = []
    for s, r in hits[:top_k]:
        results.append({
            "product_name": str(r.get(INV_NAME_COL, "")),
            "variant": str(r.get(INV_VARIANT_COL, "")) if INV_VARIANT_COL else "",
            "sku": str(r.get(INV_SKU_COL, "")) if INV_SKU_COL else "",
            "stock": r.get(INV_STOCK_COL, "") if INV_STOCK_COL else "",
            "price": r.get(INV_PRICE_COL, "") if INV_PRICE_COL else "",
            "_score": s
        })
    return results

def parse_user_identity(text: str, explicit_email=None, explicit_phone=None, explicit_order=None):
    # extract hints
    email = explicit_email or (re.search(r"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}", text or "") or [None])
    email = email.group(0) if hasattr(email, "group") else (explicit_email or None)
    phone = explicit_phone or (re.search(r"\b(?:\+?\d[\d -]{6,}\d)\b", text or "") or [None])
    phone = phone.group(0) if hasattr(phone, "group") else (explicit_phone or None)
    ordno = explicit_order or (re.search(r"\b(?:[A-Z]{2,}-?\d{5,}|#?\d{5,})\b", text or "") or [None])
    ordno = ordno.group(0).lstrip("#") if hasattr(ordno, "group") else (explicit_order or None)
    return email, phone, ordno

def find_customer(email=None, phone=None, name=None):
    if cust_df.empty:
        return None
    df = cust_df
    if email and CUST_EMAIL_COL:
        m = df[df[CUST_EMAIL_COL].astype(str).str.lower() == email.lower()]
        if not m.empty: return m.iloc[0].to_dict()
    if phone and CUST_PHONE_COL:
        norm = re.sub(r"\D", "", phone)
        m = df[df[CUST_PHONE_COL].astype(str).str.replace(r"\D","",regex=True) == norm]
        if not m.empty: return m.iloc[0].to_dict()
    if name and CUST_NAME_COL:
        m = df[df[CUST_NAME_COL].astype(str).str.lower().str.contains(name.lower())]
        if not m.empty: return m.iloc[0].to_dict()
    return None

def find_orders(email=None, phone=None, order_number=None, customer_id=None, top_k=5):
    if orders_df.empty:
        return []
    df = orders_df.copy()
    # email
    if email and ORD_EMAIL_COL:
        df = pd.concat([df[df[ORD_EMAIL_COL].astype(str).str.lower() == email.lower()], df[0:0]])
    # order number
    if order_number and ORD_NUM_COL:
        m = orders_df[orders_df[ORD_NUM_COL].astype(str).str.replace("#","",regex=False).str.lower() == str(order_number).lower()]
        df = pd.concat([df, m])
    # customer id
    if customer_id and ORD_CUST_ID_COL:
        m = orders_df[orders_df[ORD_CUST_ID_COL].astype(str) == str(customer_id)]
        df = pd.concat([df, m])
    # phone: if orders table lacks phone, try via customer join
    if phone and CUST_PHONE_COL and ORD_CUST_ID_COL and CUST_ID_COL:
        norm = re.sub(r"\D","", phone)
        cust_matches = cust_df[cust_df[CUST_PHONE_COL].astype(str).str.replace(r"\D","",regex=True) == norm]
        if not cust_matches.empty:
            ids = cust_matches[CUST_ID_COL].astype(str).unique().tolist()
            m = orders_df[orders_df[ORD_CUST_ID_COL].astype(str).isin(ids)]
            df = pd.concat([df, m])
    if df.empty:
        return []
    # sort by created desc
    if ORD_CREATED_COL:
        df["_ts"] = df[ORD_CREATED_COL].apply(to_datetime_safe)
        df = df.sort_values("_ts", ascending=False)
    df = df.drop_duplicates(subset=[c for c in [ORD_ID_COL, ORD_NUM_COL] if c])
    rows = []
    for _, r in df.head(top_k).iterrows():
        rows.append({
            "order_id": r.get(ORD_ID_COL, ""),
            "order_number": r.get(ORD_NUM_COL, ""),
            "email": r.get(ORD_EMAIL_COL, ""),
            "status": r.get(ORD_STATUS_COL, "") or r.get(ORD_FULFILL_COL, ""),
            "payment_status": r.get(ORD_PAY_COL, ""),
            "created_at": str(r.get(ORD_CREATED_COL, "")),
            "fulfilled_at": str(r.get(ORD_FULFILLED_COL, "")),
            "total": r.get(ORD_TOTAL_COL, "")
        })
    return rows

def active_promos(at_time=None, code_like=None, channel_like=None):
    if camp_df.empty:
        return []
    at_time = at_time or datetime.now()
    results = []
    for _, r in camp_df.iterrows():
        code = str(r.get(CAMP_CODE_COL, "") if CAMP_CODE_COL else "").strip()
        chan = str(r.get(CAMP_CHANNEL_COL, "") if CAMP_CHANNEL_COL else "").strip()
        name = str(r.get(CAMP_NAME_COL, "") if CAMP_NAME_COL else "").strip()
        start = to_datetime_safe(r.get(CAMP_START_COL)) if CAMP_START_COL else None
        end = to_datetime_safe(r.get(CAMP_END_COL)) if CAMP_END_COL else None
        if start and at_time < start: 
            continue
        if end and at_time > end:
            continue
        if code_like and code_like.lower() not in code.lower():
            continue
        if channel_like and chan and channel_like.lower() not in chan.lower():
            continue
        results.append({
            "promo_code": code,
            "campaign_name": name,
            "channel": chan,
            "start": start.isoformat() if start else "",
            "end": end.isoformat() if end else ""
        })
    return results

def sales_summary(text_query=""):
    if sales_df.empty:
        return {}
    df = sales_df.copy()
    # Date filter
    start, end = parse_date_range_from_text(text_query or "")
    if SALE_DATE_COL:
        df["_date"] = df[SALE_DATE_COL].apply(to_datetime_safe)
        if start: df = df[df["_date"] >= start]
        if end: df = df[df["_date"] <= end]
    # Metrics
    units_col = SALE_UNITS_COL
    rev_col = SALE_REV_COL
    df["_units"] = df[units_col].apply(sanitize_float) if units_col else 0
    df["_rev"] = df[rev_col].apply(sanitize_float) if rev_col else 0.0
    total_units = float(df["_units"].sum() if units_col else 0)
    total_revenue = float(df["_rev"].sum() if rev_col else 0)
    # top sellers
    group_cols = [c for c in [SALE_NAME_COL, SALE_SKU_COL] if c]
    top = []
    if group_cols:
        g = df.groupby(group_cols).agg(units=("_units","sum"), revenue=("_rev","sum")).reset_index()
        g = g.sort_values(["revenue","units"], ascending=False).head(5)
        for _, r in g.iterrows():
            top.append({
                "product_name": str(r.get(SALE_NAME_COL, "")) if SALE_NAME_COL else "",
                "sku": str(r.get(SALE_SKU_COL, "")) if SALE_SKU_COL else "",
                "units": float(r.get("units", 0)),
                "revenue": float(r.get("revenue", 0)),
            })
    return {
        "total_units": total_units,
        "total_revenue": total_revenue,
        "top_sellers": top
    }

def campaign_summary(text_query=""):
    if camp_df.empty:
        return {}
    df = camp_df.copy()
    start, end = parse_date_range_from_text(text_query or "")
    # date filter
    if CAMP_START_COL or CAMP_END_COL:
        def is_in_range(r):
            s = to_datetime_safe(r.get(CAMP_START_COL)) if CAMP_START_COL else None
            e = to_datetime_safe(r.get(CAMP_END_COL)) if CAMP_END_COL else None
            if start and s and e and (e < start or s > end):
                return False
            if start and not s and e and e < start:
                return False
            if end and not e and s and s > end:
                return False
            return True
        if start or end:
            df = df[df.apply(is_in_range, axis=1)]
    # compute ROAS, CTR, CPC if possible
    if CAMP_SPEND_COL and CAMP_REV_COL:
        df["_spend"] = df[CAMP_SPEND_COL].apply(sanitize_float)
        df["_rev"] = df[CAMP_REV_COL].apply(sanitize_float)
        df["_roas"] = df.apply(lambda r: (r["_rev"]/r["_spend"]) if r["_spend"] and r["_spend"]>0 else None, axis=1)
    if CAMP_CLICKS_COL and CAMP_IMP_COL:
        df["_ctr"] = df.apply(lambda r: (float(r.get(CAMP_CLICKS_COL,0))/float(r.get(CAMP_IMP_COL,1))) if float(r.get(CAMP_IMP_COL,1))>0 else None, axis=1)
    if CAMP_SPEND_COL and CAMP_CLICKS_COL:
        df["_cpc"] = df.apply(lambda r: (float(r.get(CAMP_SPEND_COL,0))/float(r.get(CAMP_CLICKS_COL,1))) if float(r.get(CAMP_CLICKS_COL,1))>0 else None, axis=1)

    rows = []
    for _, r in df.head(10).iterrows():
        rows.append({
            "campaign_name": r.get(CAMP_NAME_COL, ""),
            "promo_code": r.get(CAMP_CODE_COL, "") if CAMP_CODE_COL else "",
            "channel": r.get(CAMP_CHANNEL_COL, "") if CAMP_CHANNEL_COL else "",
            "start": str(r.get(CAMP_START_COL, "")) if CAMP_START_COL else "",
            "end": str(r.get(CAMP_END_COL, "")) if CAMP_END_COL else "",
            "spend": r.get(CAMP_SPEND_COL, "") if CAMP_SPEND_COL else "",
            "revenue": r.get(CAMP_REV_COL, "") if CAMP_REV_COL else "",
            "roas": r.get("_roas", ""),
            "ctr": r.get("_ctr", ""),
            "cpc": r.get("_cpc", "")
        })
    return {"campaigns": rows}

# --- LLM helpers ---
def build_system_prompt():
    return (
        "You are a helpful customer support and analytics assistant for a company that sells nuts. "
        "Answer concisely. Use provided context when possible. If unsure, say you'll check."
    )

def build_user_prompt(user_msg, faq_hits, inv_hits, order_hits, promo_hits, sales_sum, camp_sum, cust_match):
    parts = [f"User message:\n{user_msg}\n"]
    def add(title, lines):
        if lines:
            parts.append(f"{title}:\n" + "\n".join(lines))
    add("FAQs", [f"- Q: {h['question']}\n  A: {h['answer']}" for h in (faq_hits or [])])
    add("Inventory", [f"- {i.get('product_name','')} {i.get('variant','')} (SKU {i.get('sku','')}) Stock:{i.get('stock','')} Price:{i.get('price','')}" for i in (inv_hits or [])])
    add("Orders", [f"- #{o.get('order_number','')} Status:{o.get('status','')} Total:{o.get('total','')} Created:{o.get('created_at','')}" for o in (order_hits or [])])
    add("Promos (active)", [f"- {p.get('promo_code','')} ({p.get('campaign_name','')}) ends {p.get('end','')}" for p in (promo_hits or [])])
    if sales_sum:
        parts.append("Sales summary:")
        parts.append(f"- Total units: {sales_sum.get('total_units',0)}  Total revenue: {sales_sum.get('total_revenue',0)}")
        if sales_sum.get("top_sellers"):
            for s in sales_sum["top_sellers"]:
                parts.append(f"- Top: {s.get('product_name','')} ({s.get('sku','')}) units {s.get('units',0)} revenue {s.get('revenue',0)}")
    if camp_sum and camp_sum.get("campaigns"):
        parts.append("Campaign highlights:")
        for r in camp_sum["campaigns"][:5]:
            parts.append(f"- {r.get('campaign_name','')} code {r.get('promo_code','')} ROAS {r.get('roas','')} CTR {r.get('ctr','')}")
    if cust_match:
        parts.append(f"Customer matched: id {cust_match.get(CUST_ID_COL,'')} email {cust_match.get(CUST_EMAIL_COL,'')} phone {cust_match.get(CUST_PHONE_COL,'')}")
    parts.append("\nPlease answer succinctly (2-6 sentences). If asked for order number/status, answer directly. If promo code asked, provide code and expiry if known.")
    return "\n".join(parts)

def call_bitdeer_chat(model: str, messages: list, temperature: float = 0.2, max_tokens: int = 512):
    if not BITDEER_API_KEY:
        raise RuntimeError("BITDEER_API_KEY environment variable not set.")
    headers = {
        "Authorization": f"Bearer {BITDEER_API_KEY}",
        "Content-Type": "application/json",
    }
    payload = {
        "model": model,
        "messages": messages,
        "max_tokens": max_tokens,
        "temperature": temperature,
        "frequency_penalty": 0,
        "presence_penalty": 0,
        "top_p": 1,
        "stream": False
    }
    resp = requests.post(BITDEER_CHAT_URL, headers=headers, data=json.dumps(payload), timeout=60)
    if not resp.ok:
        raise RuntimeError(f"Bitdeer API error {resp.status_code}: {resp.text}")
    try:
        data = resp.json()
    except Exception as e:
        raise RuntimeError(f"Invalid JSON from API: {e}; body: {resp.text[:500]}")
    content = ""
    try:
        content = data.get("choices", [{}])[0].get("message", {}).get("content", "")
    except Exception:
        pass
    if not content:
        content = data.get("choices", [{}])[0].get("text") or ""
    if not content:
        raise RuntimeError(f"No content in response. Raw: {json.dumps(data)[:800]}")
    return content.strip()

# --- Intent detection ---
def detect_intents(text):
    t = (text or "").lower()
    intents = set()
    # basic classifiers
    if any(k in t for k in ["return policy","refund","shipping","delivery","time","how long","do you ship","international","warranty","allergy"]):
        intents.add("faq")
    if any(k in t for k in ["stock","inventory","price","sku","size","grade","available","availability","in stock"]):
        intents.add("inventory")
    if any(k in t for k in ["sales","revenue","top seller","top-seller","best seller","aov","units","trend","last 30","this month","last month","this year"]):
        intents.add("sales")
    if any(k in t for k in ["campaign","promo","promotion","coupon","code","discount","roas","ctr","cpc"]):
        intents.add("campaigns")
    if any(k in t for k in ["customer","segment","repeat","rpr","lifetime","ltv"]):
        intents.add("customers")
    if any(k in t for k in ["order","order number","status","tracking","where is my","wismo"]):
        intents.add("orders")
    # default
    if not intents:
        intents.update(["faq","inventory"])
    return intents

# --- Flask UI ---
INDEX_HTML = """
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Cashew Chatbot (Local)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { background:#0f172a; color:#e5e7eb; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin:0; }
    .container { max-width: 1000px; margin: 0 auto; padding: 24px; }
    h1 { font-size: 24px; margin: 0 0 12px; }
    .card { background: #111827; border:1px solid rgba(255,255,255,0.08); border-radius: 12px; padding:16px; }
    label { display:block; font-size: 14px; margin: 8px 0 4px; color:#cbd5e1; }
    select, input[type=text], textarea { width:100%; background:#0b1220; color:#e5e7eb; border:1px solid rgba(255,255,255,0.12); border-radius:8px; padding:10px; box-sizing:border-box; }
    button { background:#2563eb; color:white; border:none; padding:10px 14px; border-radius:8px; cursor:pointer; }
    button:disabled { background:#334155; cursor:not-allowed; }
    .row { display:flex; gap:16px; flex-wrap:wrap; }
    .row > div { flex:1; min-width: 220px; }
    .chat { margin-top: 16px; }
    .msg { padding:10px 12px; margin:8px 0; border-radius:8px; }
    .user { background:#1f2937; }
    .bot { background:#0b1220; border:1px solid rgba(255,255,255,0.08); white-space:pre-wrap; }
    .small { font-size:12px; color:#94a3b8; }
    .footer { margin-top:12px; font-size:12px; color:#94a3b8; }
    .ctx { font-size:12px; color:#a3e635; white-space:pre-wrap; margin-top:8px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Cashew Chatbot</h1>
    <div class="card">
      <div class="row">
        <div>
          <label for="model">Model</label>
          <select id="model">
            <option value="{{MODEL_GPT_OSS}}">GPT-OSS (120B)</option>
            <option value="{{MODEL_QWEN3}}">Qwen3 (235B)</option>
          </select>
        </div>
        <div>
          <label>Data Directory</label>
          <input type="text" value="{{data_dir}}" disabled>
          <div class="small">Using FAQs, Inventory, Sales, Campaigns, Customers, Orders if present.</div>
        </div>
        <div>
          <label for="email">Customer Email</label>
          <input id="email" type="text" placeholder="customer@example.com (optional)">
        </div>
        <div>
          <label for="phone">Customer Phone</label>
          <input id="phone" type="text" placeholder="+1 555 123 4567 (optional)">
        </div>
        <div>
          <label for="ordno">Order Number</label>
          <input id="ordno" type="text" placeholder="#12345 (optional)">
        </div>
      </div>

      <div class="chat" id="chat"></div>

      <label for="msg">Your message</label>
      <textarea id="msg" rows="3" placeholder="Ask anything... e.g., What's my order status? Any active promo codes? Top sellers last 30 days?"></textarea>
      <div style="margin-top:8px">
        <button id="send">Send</button>
        <span class="small" id="status"></span>
      </div>

      <div class="footer">
        API key loaded from environment: <strong>{{ 'Yes' if has_key else 'No' }}</strong>. Local demo; do not expose publicly.
      </div>
    </div>
  </div>

  <script>
    const chat = document.getElementById('chat');
    const msg = document.getElementById('msg');
    const model = document.getElementById('model');
    const sendBtn = document.getElementById('send');
    const status = document.getElementById('status');
    const email = document.getElementById('email');
    const phone = document.getElementById('phone');
    const ordno = document.getElementById('ordno');

    function addMsg(text, who) {
      const div = document.createElement('div');
      div.className = 'msg ' + (who === 'user' ? 'user' : 'bot');
      div.textContent = text;
      chat.appendChild(div);
      chat.scrollTop = chat.scrollHeight;
    }

    function addContext(text) {
      const pre = document.createElement('div');
      pre.className = 'ctx';
      pre.textContent = text;
      chat.appendChild(pre);
      chat.scrollTop = chat.scrollHeight;
    }

    async function send() {
      const content = msg.value.trim();
      if (!content) return;
      addMsg(content, 'user');
      msg.value = '';
      sendBtn.disabled = true;
      status.textContent = 'Thinking...';

      try {
        const res = await fetch('/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            message: content, 
            model: model.value,
            email: email.value,
            phone: phone.value,
            order_number: ordno.value
          })
        });
        const data = await res.json();
        if (data.context) {
          addContext("Data I used:\\n" + data.context);
        }
        addMsg(data.reply || data.error || '(no reply)', 'bot');
      } catch (e) {
        addMsg('Error: ' + (e && e.message ? e.message : e), 'bot');
      } finally {
        status.textContent = '';
        sendBtn.disabled = false;
      }
    }

    sendBtn.addEventListener('click', send);
    msg.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) send();
    });
  </script>
</body>
</html>
"""

@app.route("/")
def index():
    return render_template_string(
        INDEX_HTML,
        MODEL_GPT_OSS=MODEL_GPT_OSS,
        MODEL_QWEN3=MODEL_QWEN3,
        data_dir=str(DATA_DIR),
        has_key=bool(BITDEER_API_KEY),
    )

@app.route("/chat", methods=["POST"])
def chat_route():
    try:
        data = request.get_json(force=True)
        user_msg = (data.get("message") or "").strip()
        model = data.get("model") or DEFAULT_MODEL
        explicit_email = (data.get("email") or "").strip() or None
        explicit_phone = (data.get("phone") or "").strip() or None
        explicit_order = (data.get("order_number") or "").strip() or None

        if not user_msg:
            return jsonify({"error": "Empty message"}), 400

        # Detect intents
        intents = detect_intents(user_msg)

        # Identity hints
        parsed_email, parsed_phone, parsed_ordno = parse_user_identity(user_msg, explicit_email, explicit_phone, explicit_order)

        # Retrieval
        faq_hits = search_faqs(user_msg, top_k=3) if "faq" in intents else []
        inv_hits = search_inventory(user_msg, top_k=5) if "inventory" in intents else []
        sales_sum = sales_summary(user_msg) if "sales" in intents else {}
        camp_sum = campaign_summary(user_msg) if "campaigns" in intents else {}

        cust_match = None
        if "orders" in intents or parsed_email or parsed_phone:
            cust_match = find_customer(email=parsed_email, phone=parsed_phone, name=None)

        order_hits = []
        if "orders" in intents or parsed_ordno or cust_match:
            order_hits = find_orders(
                email=parsed_email or (cust_match.get(CUST_EMAIL_COL) if cust_match and CUST_EMAIL_COL else None),
                phone=parsed_phone,
                order_number=parsed_ordno,
                customer_id=(cust_match.get(CUST_ID_COL) if cust_match and CUST_ID_COL else None),
                top_k=5
            )

        promo_hits = []
        if "campaigns" in intents or any(k in user_msg.lower() for k in ["promo","code","coupon","discount"]):
            code_like = None
            m = re.search(r"\b[A-Z0-9]{4,}\b", user_msg.upper())
            if m:
                code_like = m.group(0)
            promo_hits = active_promos(code_like=code_like)

        # Build LLM prompt
        sys_prompt = build_system_prompt()
        user_prompt = build_user_prompt(user_msg, faq_hits, inv_hits, order_hits, promo_hits, sales_sum, camp_sum, cust_match)
        messages = [
            {"role": "system", "content": sys_prompt},
            {"role": "user", "content": user_prompt}
        ]

        reply = call_bitdeer_chat(model, messages, temperature=0.2, max_tokens=600)

        # Prepare a context echo
        ctx_lines = []
        if faq_hits:
            ctx_lines.append("FAQs:")
            for h in faq_hits:
                ctx_lines.append(f"- {h['question']} -> {h['answer']}")
        if inv_hits:
            ctx_lines.append("Inventory:")
            for it in inv_hits:
                ctx_lines.append(f"- {it.get('product_name','')} {it.get('variant','')} (SKU {it.get('sku','')}) Stock:{it.get('stock','')} Price:{it.get('price','')}")
        if cust_match:
            ctx_lines.append(f"Customer: id {cust_match.get(CUST_ID_COL,'')} email {cust_match.get(CUST_EMAIL_COL,'')} phone {cust_match.get(CUST_PHONE_COL,'')}")
        if order_hits:
            ctx_lines.append("Orders:")
            for o in order_hits:
                ctx_lines.append(f"- #{o.get('order_number','')} Status:{o.get('status','')} Total:{o.get('total','')} Created:{o.get('created_at','')}")
        if promo_hits:
            ctx_lines.append("Active promos:")
            for p in promo_hits[:5]:
                ctx_lines.append(f"- {p.get('promo_code','')} ends {p.get('end','')} (campaign {p.get('campaign_name','')})")
        if sales_sum:
            ctx_lines.append(f"Sales: total_units={sales_sum.get('total_units',0)} total_revenue={sales_sum.get('total_revenue',0)}")
            if sales_sum.get("top_sellers"):
                for s in sales_sum["top_sellers"]:
                    ctx_lines.append(f"- Top seller: {s.get('product_name','')} ({s.get('sku','')}) units {s.get('units',0)} revenue {s.get('revenue',0)}")
        if camp_sum and camp_sum.get("campaigns"):
            ctx_lines.append("Campaigns:")
            for r in camp_sum["campaigns"][:5]:
                ctx_lines.append(f"- {r.get('campaign_name','')} code {r.get('promo_code','')} ROAS {r.get('roas','')}")

        return jsonify({"reply": reply, "context": "\n".join(ctx_lines)})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

def run():
    try:
        from waitress import serve
        print("Starting server with waitress on http://127.0.0.1:5000")
        serve(app, host="127.0.0.1", port=5000)
    except Exception as e:
        print(f"[WARN] Waitress failed ({e}); falling back to Flask dev server.")
        app.run(host="127.0.0.1", port=5000, debug=False)

if __name__ == "__main__":
    run()
